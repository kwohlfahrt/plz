#!/usr/bin/env zsh

set -e
set -u
set -o err_return
set -o pipefail

autoload -U colors && colors

cd ${0:a:h:h}

PROJECT_NAME=plztest
NETWORK="${PROJECT_NAME}_default"
VOLUME_PREFIX="${PROJECT_NAME}_data_"
CLI_BUILDER_IMAGE="${PROJECT_NAME}/cli-builder"
CLI_IMAGE="${PROJECT_NAME}/cli"
CLI_CONTAINER_PREFIX="${PROJECT_NAME}_cli_"
CONTROLLER_IMAGE="${PROJECT_NAME}/controller"
CONTROLLER_CONTAINER="${PROJECT_NAME}_controller_1"
CONTROLLER_PORT=80

TEST_DIRECTORY=${0:a:h}
DATA_DIRECTORY="${PWD}/cache/test"

mkdir -p $DATA_DIRECTORY

function docker_compose {
  docker-compose \
  --project-name="$PROJECT_NAME" \
  --file="${TEST_DIRECTORY}/docker-compose.yml" \
  $@
}

if [[ -t 1 ]]; then
  function info {
    echo "${fg[green]}>${reset_color} $@"
  }
  function warning {
    echo "${fg[yellow]}>${reset_color} $@"
  }
  function error {
    echo "${fg[red]}>${reset_color} $@"
  }
else
  function info {
    echo > $@
  }
  function warning {
    echo > $@
  }
  function error {
    echo > $@
  }
fi

# In "bless mode", instead of comparing the actual output against expected
# output, we save the output.
bless=false
# In "parallel mode", tests run in parallel.
parallel=false
while [[ $# -gt 0 ]]; do
  case $1 in
    --bless)
      bless=true
      shift ;;
    --parallel)
      parallel=true
      shift ;;
    *)
      break
  esac
done

if [[ $# -eq 0 ]]; then
  # Run all tests.
  tests=($(find $TEST_DIRECTORY -mindepth 1 -maxdepth 1 -type d -not -name '*.ignored' | sort))
else
  # Run selected tests.
  # But first, verify all arguments are actually test directories.
  for dir in $@; do
    if [[ ${dir:a} != "${TEST_DIRECTORY}/${dir:t}" ]]; then
      echo "\"${dir}\" is not a test directory."
      exit 2
    fi
  done
  tests=($@)
fi

function start_controller {
  info "Building the controller..."
  docker image build --quiet --tag=$CONTROLLER_IMAGE services/controller

  if container_exists $CONTROLLER_CONTAINER; then
    warning "Controller already exists. Stopping..."
    stop_controller
  fi

  info "Starting the controller..."
  docker_compose up --quiet-pull --detach
}

function stop_controller {
  docker_compose stop
  docker_compose logs
  docker_compose down --volumes
}

function build_cli {
  info "Building the CLI..."
  docker image build --quiet --target=builder --tag=$CLI_BUILDER_IMAGE cli
  docker image build --quiet --tag=$CLI_IMAGE cli
}

function run_test {
  test=${test:a}
  echo
  info "Running ${test:t}..."

  if [[ -f "${test}/expected-status" ]]; then
    expected_exit_status=$(cat "${test}/expected-status")
  else
    expected_exit_status=0
  fi
  actual_exit_status_file=$(mktemp "${DATA_DIRECTORY}/plz-test-status.XXXXX")
  expected_logs="${test}/expected-logs"
  actual_logs=$(mktemp "${DATA_DIRECTORY}/plz-test-logs.XXXXX")
  expected_output_directory="${test}/expected-output"
  actual_output_directory=$(mktemp "${DATA_DIRECTORY}/plz-test-output.XXXXX")
  rm $actual_output_directory # It's been created as a file.

  start=$(date +%s)
  run_cli $test $actual_exit_status_file $actual_logs $actual_output_directory
  end=$(date +%s)

  info "Time taken: $((end - start))s."

  success=true
  actual_exit_status=$(cat $actual_exit_status_file)
  if $bless; then
    if [[ $actual_exit_status -eq $expected_exit_status ]]; then
      info 'Blessing output...'
      cp $actual_logs $expected_logs
      rm -rf $expected_output_directory
      if [[ -e $actual_output_directory ]]; then
        cp -R $actual_output_directory $expected_output_directory
      fi
      info 'Test blessed.'
    else
      error "Exited with a status code of ${actual_exit_status}."
      success=false
    fi
  else
    if [[ $actual_exit_status -ne $expected_exit_status ]]; then
      success=false
      error "Exited with a status code of ${actual_exit_status}."
      error "Expected a status code of ${expected_exit_status}."
      error 'Test failed.'
    else
      info 'Comparing output...'
      if git diff --no-index $expected_logs $actual_logs && \
         ( ! [[ -e $expected_output_directory ]] || \
           git diff --no-index $expected_output_directory $actual_output_directory ); then
        info 'Test passed.'
      else
        success=false
        error 'Test failed.'
      fi
    fi
  fi

  $success
}

function run_cli {
  app_directory=${1:a}
  exit_status_file=${2:a}
  logs_file=${3:a}
  output_directory=${4:a}
  test_config_file="${app_directory}/test.config.json"
  suffix=$(slug ${app_directory:t})
  cli_container="${CLI_CONTAINER_PREFIX}_${suffix}"
  volume="${VOLUME_PREFIX}_${suffix}"

  args=()
  if [[ -f $test_config_file ]]; then
    IFS=$'\n' args=($(jq -r '(.args // []) | .[]' < $test_config_file))
  fi

  # Add the app directory to a Docker volume.
  docker volume create $volume > /dev/null
  docker run \
    --name=$volume \
    --detach \
    --interactive \
    --volume=$volume:/data \
    docker:stable-git \
    /bin/cat \
    > /dev/null
  docker container cp $app_directory $volume:/data/app

  # Initialize a Git repository to make excludes work.
  docker container run \
    --rm \
    --volume=$volume:/data \
    docker:stable-git \
    git init --quiet /data/app

  # Start the CLI process.
  docker container run \
    --name=$cli_container \
    --detach \
    --network=$NETWORK \
    --env=PLZ_HOST=$PLZ_HOST \
    --env=PLZ_PORT=$PLZ_PORT \
    --env=PLZ_QUIET_BUILD=true \
    --workdir=/data/app \
    --volume="${volume}:/data" \
    $CLI_IMAGE \
    run --output=/data/output $args \
    > /dev/null

  # Capture the logs and exit status.
  docker container logs --follow $cli_container \
    |& redact_uuids \
    |& redact_instance_status \
    | tee $logs_file
  docker wait $cli_container > $exit_status_file
  docker container rm $cli_container > /dev/null

  # Extract the output.
  docker container exec $volume sh -c '[ ! -d /data/output ]' \
    || docker container cp $volume:/data/output $output_directory
  remove_volume $volume
}

function cleanup {
  exit_status=$?
  stop_all_clis
  stop_controller
  remove_all_volumes
  return $exit_status
}

function stop_all_clis {
  for container in $(docker container ls --quiet --all --filter=name="${CLI_CONTAINER_PREFIX}"); do
    stop_cli $container
  done
}

function stop_cli {
  if ! container_exists $1; then
    return
  fi
  docker container stop $1 > /dev/null || :
  docker container rm $1 > /dev/null || :
  info "CLI stopped."
}

function remove_all_volumes {
  for volume in $(docker volume ls --quiet --filter=name="${VOLUME_PREFIX}"); do
    remove_volume $volume
  done
}

function remove_volume {
  if container_exists $1; then
    docker container kill $1 >& /dev/null || :
    docker container rm $1 > /dev/null
  fi
  if volume_exists $1; then
    docker volume rm $1 > /dev/null
  fi
}

function container_exists {
  docker container inspect $1 >& /dev/null
}

function volume_exists {
  docker volume inspect $1 >& /dev/null
}

function redact_uuids {
  # The "$| = 1" bit disables buffering so we get output as we need it.
  perl -pe '$| = 1; s/\b[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}\b/<UUID>/g'
}

function slug {
  tr -C '[A-Za-z0-9_\n]' '_' <<< $1
}

function redact_instance_status {
  grep -v '^Instance status: '
}

trap 'exit_early=true; cleanup' EXIT INT TERM

build_cli

if (( ${+PLZ_HOST} )) && (( ${+PLZ_PORT} )); then
  NETWORK=host
else
  start_controller
  PLZ_HOST=$CONTROLLER_CONTAINER
  PLZ_PORT=$CONTROLLER_PORT
fi
export PLZ_HOST
export PLZ_PORT

exit_early=false
success_file=$(mktemp "${DATA_DIRECTORY}/plz-test-success.XXXXX")
pids=()
for test in $tests; do
  if $parallel; then
    (
      test_output=$(run_test $test 2>&1) || rm -f $success_file
      echo $test_output
    ) & pids+=($!)
  else
    run_test $test || rm -f $success_file
  fi
done

if $parallel; then
  for pid in $pids; do
    wait $pid
  done
fi

echo
[[ -e $success_file ]]
